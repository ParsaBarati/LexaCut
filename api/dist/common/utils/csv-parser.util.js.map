{"version":3,"sources":["../../../src/common/utils/csv-parser.util.ts"],"sourcesContent":["import { Readable } from 'stream';\nimport csv from 'csv-parser';\nimport * as XLSX from 'xlsx';\nimport { ComponentData } from '../interfaces';\nimport { getBackendFieldName, LEXACUT_COLUMN_MAP } from './lexacut-column-mapper';\n\n/**\n * CSV Parser for \"All\" sheet data\n * Parses the CSV input that mimics Excel \"All\" sheet structure\n */\n\nexport interface CSVRow {\n  [key: string]: string;\n}\n\n/**\n * Check if buffer is an Excel file (starts with PK\\x03\\x04 ZIP signature)\n */\nfunction isExcelFile(buffer: Buffer): boolean {\n  return buffer.length >= 4 && buffer[0] === 0x50 && buffer[1] === 0x4B && buffer[2] === 0x03 && buffer[3] === 0x04;\n}\n\n/**\n * Parse Excel file into ComponentData array\n * @param buffer - Buffer containing Excel file data\n * @returns Array of ComponentData\n */\nfunction parseExcelFile(buffer: Buffer): ComponentData[] {\n  console.log('Detected Excel file, parsing with xlsx...');\n  \n  try {\n    // Parse Excel workbook\n    const workbook = XLSX.read(buffer, { type: 'buffer' });\n    \n    // Get first sheet (or look for \"All\" sheet)\n    const sheetName = workbook.SheetNames.find(name => \n      name.toLowerCase().includes('all') || name.toLowerCase().includes('sheet')\n    ) || workbook.SheetNames[0];\n    \n    console.log(`Reading sheet: ${sheetName}`);\n    const worksheet = workbook.Sheets[sheetName];\n    \n    // Convert to JSON (array of objects)\n    const rows = XLSX.utils.sheet_to_json(worksheet, { defval: '' }) as CSVRow[];\n    \n    console.log(`Excel parsing: Read ${rows.length} rows from sheet \"${sheetName}\"`);\n    if (rows.length > 0) {\n      console.log('First Excel row keys:', Object.keys(rows[0]));\n      console.log('First Excel row:', rows[0]);\n    }\n    \n    // Map rows to components\n    const components = rows\n      .map(mapRowToComponent)\n      .filter(comp => {\n        // Filter out completely empty rows\n        const hasLength = comp.length > 0;\n        const hasWidth = comp.width > 0;\n        const hasQuantity = comp.quantity > 0;\n        const hasArea = comp.area > 0;\n        const hasMaterial = comp.materialType && comp.materialType.trim() !== '';\n        const hasName = comp.name && comp.name.trim() !== '' && comp.name !== 'Component';\n        const hasComponentId = comp.componentId && comp.componentId.trim() !== '';\n        \n        const isValid = hasLength || hasWidth || hasQuantity || hasArea || hasMaterial || hasName || hasComponentId;\n        \n        if (isValid) {\n          console.log('Valid component:', {\n            name: comp.name,\n            material: comp.materialType,\n            length: comp.length,\n            width: comp.width,\n            quantity: comp.quantity,\n            area: comp.area,\n          });\n        }\n        \n        return isValid;\n      });\n    \n    console.log(`Excel parsing: ${rows.length} rows read, ${components.length} valid components`);\n    return components;\n  } catch (error) {\n    console.error('Error parsing Excel file:', error);\n    throw new Error(`Failed to parse Excel file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\n/**\n * Parse CSV file/stream into ComponentData array\n * Supports both CSV and Excel (.xlsx) files\n * @param input - Readable stream or Buffer containing CSV or Excel data\n * @returns Promise resolving to array of ComponentData\n */\nexport async function parseCSV(input: Readable | Buffer): Promise<ComponentData[]> {\n  // Convert to buffer if needed\n  let buffer: Buffer;\n  \n  if (input instanceof Buffer) {\n    buffer = input;\n  } else {\n    // Read stream into buffer\n    const chunks: Buffer[] = [];\n    for await (const chunk of input) {\n      chunks.push(chunk);\n    }\n    buffer = Buffer.concat(chunks);\n  }\n  \n  // Check if it's an Excel file\n  if (isExcelFile(buffer)) {\n    return parseExcelFile(buffer);\n  }\n  \n  // Otherwise, parse as CSV\n  console.log('Detected CSV file, parsing with csv-parser...');\n  const stream = Readable.from(buffer);\n  const rows: CSVRow[] = [];\n  \n  return new Promise((resolve, reject) => {\n    stream\n      .pipe(csv())\n      .on('data', (row: CSVRow) => {\n        // Log first row to see structure\n        if (rows.length === 0) {\n          console.log('First CSV row keys:', Object.keys(row));\n          console.log('First CSV row:', row);\n        }\n        rows.push(row);\n      })\n      .on('end', () => {\n        console.log(`CSV parsing: Read ${rows.length} rows from CSV`);\n        try {\n          const components = rows\n            .map(mapRowToComponent)\n            .filter(comp => {\n              // Filter out completely empty rows\n              const hasLength = comp.length > 0;\n              const hasWidth = comp.width > 0;\n              const hasQuantity = comp.quantity > 0;\n              const hasArea = comp.area > 0;\n              const hasMaterial = comp.materialType && comp.materialType.trim() !== '';\n              const hasName = comp.name && comp.name.trim() !== '' && comp.name !== 'Component';\n              const hasComponentId = comp.componentId && comp.componentId.trim() !== '';\n              \n              const isValid = hasLength || hasWidth || hasQuantity || hasArea || hasMaterial || hasName || hasComponentId;\n              \n              if (isValid) {\n                console.log('Valid component:', {\n                  name: comp.name,\n                  material: comp.materialType,\n                  length: comp.length,\n                  width: comp.width,\n                  quantity: comp.quantity,\n                  area: comp.area,\n                });\n              }\n              \n              return isValid;\n            });\n          \n          console.log(`CSV parsing: ${rows.length} rows read, ${components.length} valid components`);\n          resolve(components);\n        } catch (error) {\n          reject(error);\n        }\n      })\n      .on('error', reject);\n  });\n}\n\n/**\n * Map CSV row to ComponentData interface\n * Uses explicit LexaCut column mapping first, then falls back to fuzzy matching for legacy formats\n * \n * LexaCut Export Columns (optimized preset):\n * - Number → componentId\n * - Name → name\n * - Count → quantity\n * - Cutting length → length (in mm from LexaCut)\n * - Cutting width → width (in mm from LexaCut)\n * - Cutting thickness → thickness\n * - Material name → materialType\n * - Entity names → instanceType\n * - Edge ymin, ymax, xmin, xmax → edge1-4\n * - Final area → area (in m²)\n * \n * Legacy CSV Columns (fallback):\n * - Length - raw (cm) → length (mm)\n * - Width - raw (cm) → width (mm)\n * - Designation → componentId\n * - Description → name\n */\nfunction mapRowToComponent(row: CSVRow): ComponentData {\n  // Debug: Log available keys\n  const rowKeys = Object.keys(row);\n  const firstLog = rowKeys.length > 0 && !rowKeys[0].includes('Length');\n  \n  if (firstLog) {\n    console.log('CSV Row keys:', rowKeys);\n  }\n  \n  /**\n   * Get value using explicit LexaCut mapping first, then fallback to fuzzy matching\n   */\n  const getValueWithMapping = (lexacutColumn: string, legacyKeys?: string[]): string => {\n    // 1. Try exact LexaCut column name match first\n    if (row[lexacutColumn] !== undefined && row[lexacutColumn] !== null) {\n      const value = String(row[lexacutColumn]).trim();\n      if (value !== '') return value;\n    }\n    \n    // 2. Try case-insensitive match for LexaCut column\n    const found = rowKeys.find(rk => rk.toLowerCase() === lexacutColumn.toLowerCase());\n    if (found && row[found] !== undefined && row[found] !== null) {\n      const value = String(row[found]).trim();\n      if (value !== '') return value;\n    }\n    \n    // 3. Fallback to legacy keys (fuzzy matching)\n    if (legacyKeys && legacyKeys.length > 0) {\n      const allKeys = legacyKeys;\n      \n      // Try exact match\n      for (const k of allKeys) {\n        if (row[k] !== undefined && row[k] !== null && String(row[k]).trim() !== '') {\n          return String(row[k]).trim();\n        }\n      }\n      \n      // Try case-insensitive match\n      for (const k of allKeys) {\n        const legacyFound = rowKeys.find(rk => rk.toLowerCase() === k.toLowerCase());\n        if (legacyFound && row[legacyFound] !== undefined && row[legacyFound] !== null) {\n          const value = String(row[legacyFound]).trim();\n          if (value !== '') return value;\n        }\n      }\n      \n      // Try partial match (for keys with spaces/dashes)\n      for (const k of allKeys) {\n        const normalizedK = k.toLowerCase().replace(/[\\s_-]/g, '');\n        const partialFound = rowKeys.find(rk => {\n          const normalizedRk = rk.toLowerCase().replace(/[\\s_-]/g, '');\n          return normalizedRk === normalizedK || normalizedRk.includes(normalizedK);\n        });\n        if (partialFound && row[partialFound] !== undefined && row[partialFound] !== null) {\n          const value = String(row[partialFound]).trim();\n          if (value !== '') return value;\n        }\n      }\n    }\n    \n    return '';\n  };\n\n  // Check if this is LexaCut optimized format or legacy format\n  const isLexaCutFormat = rowKeys.some(k => k.toLowerCase() === 'cutting length');\n  \n  let lengthValue: number;\n  let widthValue: number;\n  let thicknessValue: number = 0;\n  \n  if (isLexaCutFormat) {\n    // LexaCut format: dimensions already in mm\n    lengthValue = parseNumber(getValueWithMapping('Cutting length'));\n    widthValue = parseNumber(getValueWithMapping('Cutting width'));\n    thicknessValue = parseNumber(getValueWithMapping('Cutting thickness'));\n    \n    if (firstLog) {\n      console.log('Detected LexaCut optimized format (dimensions in mm)');\n    }\n  } else {\n    // Legacy format: dimensions in cm, need to convert to mm\n    const lengthCm = parseNumber(getValueWithMapping('Length - raw', ['Length - raw', 'Length-raw', 'length', 'Length']));\n    const widthCm = parseNumber(getValueWithMapping('Width - raw', ['Width - raw', 'Width-raw', 'width', 'Width']));\n    lengthValue = lengthCm * 10; // Convert cm to mm\n    widthValue = widthCm * 10;   // Convert cm to mm\n    \n    if (firstLog) {\n      console.log('Detected legacy format (dimensions in cm, converting to mm)');\n    }\n  }\n  \n  // Quantity/Count\n  const quantity = parseNumber(getValueWithMapping('Count', ['Quantity', 'quantity', 'Qty']));\n  \n  // Area - parse \"0.12 m²\" format\n  const areaStr = getValueWithMapping('Final area', ['Area - final', 'Area-final', 'area', 'Area']);\n  const area = parseArea(areaStr);\n  \n  // Material\n  const materialName = getValueWithMapping('Material name', ['Material-name', 'material', 'Material']);\n  \n  // Component ID\n  const componentId = getValueWithMapping('Number', ['Designation', 'designation', 'Component ID', 'componentId']);\n  \n  // Name\n  const name = getValueWithMapping('Name', ['Description', 'description', 'name']) || \n               componentId || \n               'Component';\n  \n  // Instance/Entity names (for CNC detection)\n  const instanceType = getValueWithMapping('Entity names', ['Instance names', 'Instance-names', 'instanceType', 'Instance Type']);\n  \n  // Edge banding\n  const edge1 = getValueWithMapping('Edge ymin', ['Edge Length 1', 'Edge-Length-1', 'edge1']);\n  const edge2 = getValueWithMapping('Edge ymax', ['Edge Length 2', 'Edge-Length-2', 'edge2']);\n  const edge3 = getValueWithMapping('Edge xmin', ['Edge Width 1', 'Edge-Width-1', 'edge3']);\n  const edge4 = getValueWithMapping('Edge xmax', ['Edge Width 2', 'Edge-Width-2', 'edge4']);\n  \n  const component: ComponentData = {\n    name: name,\n    componentId: componentId,\n    quantity: quantity,\n    edge1: edge1,\n    edge2: edge2,\n    edge3: edge3,\n    edge4: edge4,\n    materialType: materialName,\n    instanceType: instanceType || '',\n    length: lengthValue,\n    width: widthValue,\n    area: area,\n  };\n  \n  // Debug logging for first valid row\n  if ((lengthValue > 0 || widthValue > 0 || quantity > 0 || area > 0 || materialName) && firstLog) {\n    console.log('Mapped component:', {\n      name,\n      componentId,\n      quantity,\n      length: lengthValue,\n      width: widthValue,\n      thickness: thicknessValue,\n      area,\n      materialName,\n      instanceType,\n      isLexaCutFormat,\n    });\n  }\n  \n  return component;\n}\n\n/**\n * Parse number from string, handling various formats\n * - Removes non-numeric characters except decimal point\n * @param value - String value to parse\n * @returns Parsed number or 0 if invalid\n */\nfunction parseNumber(value: string | undefined): number {\n  if (!value) return 0;\n  \n  // Remove non-numeric characters except decimal point and minus\n  const cleaned = String(value)\n    .replace(/[^\\d.-]/g, '')\n    .trim();\n  \n  const parsed = parseFloat(cleaned);\n  return isNaN(parsed) ? 0 : parsed;\n}\n\n/**\n * Parse area value, handling \"m²\" suffix\n * Examples: \"0.12 m²\" → 0.12, \"1.5 m²\" → 1.5\n * @param value - String value with optional \"m²\" suffix\n * @returns Parsed area in m²\n */\nfunction parseArea(value: string | undefined): number {\n  if (!value) return 0;\n  \n  // Remove \"m²\" suffix and any whitespace\n  const cleaned = String(value)\n    .replace(/m²/g, '')\n    .replace(/m\\s*²/g, '')\n    .trim();\n  \n  const parsed = parseFloat(cleaned);\n  return isNaN(parsed) ? 0 : parsed;\n}\n\n/**\n * Parse CSV with custom column mapping\n * @param input - Readable stream or Buffer\n * @param columnMap - Map of CSV column index to ComponentData field\n * @returns Promise resolving to array of ComponentData\n */\nexport async function parseCSVWithMapping(\n  input: Readable | Buffer,\n  columnMap: Record<number, keyof ComponentData>\n): Promise<ComponentData[]> {\n  const stream = (input instanceof Buffer ? Readable.from(input) : input) as Readable;\n  const rows: CSVRow[] = [];\n  \n  return new Promise((resolve, reject) => {\n    stream\n      .pipe(csv())\n      .on('data', (row: CSVRow) => rows.push(row))\n      .on('end', () => {\n        try {\n          const components = rows.map((row) => {\n            const keys = Object.keys(row);\n            const component: Partial<ComponentData> = {};\n            \n            Object.entries(columnMap).forEach(([index, field]) => {\n              const value = row[keys[parseInt(index)]];\n              \n              if (field === 'quantity' || field === 'length' || field === 'width' || field === 'area') {\n                component[field] = parseNumber(value);\n              } else {\n                (component as any)[field] = value || '';\n              }\n            });\n            \n            return component as ComponentData;\n          });\n          resolve(components);\n        } catch (error) {\n          reject(error);\n        }\n      })\n      .on('error', reject);\n  });\n}\n\n/**\n * Validate ComponentData array\n * @param components - Array of components to validate\n * @returns Object with validation results\n */\nexport function validateComponents(components: ComponentData[]): {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n} {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n  \n  // Filter out completely empty rows\n  const validComponents = components.filter((comp, idx) => {\n    const hasData = comp.length > 0 || comp.width > 0 || comp.quantity > 0 || comp.area > 0 || comp.materialType;\n    if (!hasData) {\n      warnings.push(`Row ${idx + 1}: Empty row skipped`);\n      return false;\n    }\n    return true;\n  });\n  \n  validComponents.forEach((component, index) => {\n    const rowNum = index + 1;\n    \n    // Required fields check\n    if (!component.name || component.name.trim() === '') {\n      errors.push(`Row ${rowNum}: Missing component name`);\n    }\n    \n    if (component.quantity <= 0) {\n      errors.push(`Row ${rowNum}: Invalid quantity (${component.quantity})`);\n    }\n    \n    if (!component.materialType || component.materialType.trim() === '') {\n      warnings.push(`Row ${rowNum}: Missing material type`);\n    }\n    \n    // Dimensional validation\n    if (component.length <= 0 || component.width <= 0) {\n      errors.push(`Row ${rowNum}: Invalid dimensions (L:${component.length}mm, W:${component.width}mm)`);\n    }\n    \n    // Area validation (should match length * width approximately)\n    // Allow some tolerance since area might be pre-calculated\n    if (component.area > 0 && component.length > 0 && component.width > 0) {\n      const calculatedArea = (component.length * component.width) / 1000000; // mm² to m²\n      const difference = Math.abs(calculatedArea - component.area);\n      const tolerance = Math.max(calculatedArea * 0.1, 0.01); // 10% tolerance or 0.01 m²\n      if (difference > tolerance) {\n        warnings.push(`Row ${rowNum}: Area mismatch (given: ${component.area}m², calculated: ${calculatedArea.toFixed(4)}m²)`);\n      }\n    }\n  });\n  \n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}\n\n"],"names":["parseCSV","parseCSVWithMapping","validateComponents","isExcelFile","buffer","length","parseExcelFile","console","log","workbook","XLSX","read","type","sheetName","SheetNames","find","name","toLowerCase","includes","worksheet","Sheets","rows","utils","sheet_to_json","defval","Object","keys","components","map","mapRowToComponent","filter","comp","hasLength","hasWidth","width","hasQuantity","quantity","hasArea","area","hasMaterial","materialType","trim","hasName","hasComponentId","componentId","isValid","material","error","Error","message","input","Buffer","chunks","chunk","push","concat","stream","Readable","from","Promise","resolve","reject","pipe","csv","on","row","rowKeys","firstLog","getValueWithMapping","lexacutColumn","legacyKeys","undefined","value","String","found","rk","allKeys","k","legacyFound","normalizedK","replace","partialFound","normalizedRk","isLexaCutFormat","some","lengthValue","widthValue","thicknessValue","parseNumber","lengthCm","widthCm","areaStr","parseArea","materialName","instanceType","edge1","edge2","edge3","edge4","component","thickness","cleaned","parsed","parseFloat","isNaN","columnMap","entries","forEach","index","field","parseInt","errors","warnings","validComponents","idx","hasData","rowNum","calculatedArea","difference","Math","abs","tolerance","max","toFixed"],"mappings":"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"}