{"version":3,"sources":["../../../src/common/utils/lexacut-column-mapper.ts"],"sourcesContent":["/**\n * LexaCut CSV Column Mapper\n * Explicit mapping between LexaCut export columns and backend ComponentData fields\n * This eliminates the need for fuzzy matching and ensures consistent parsing\n */\n\nexport const LEXACUT_COLUMN_MAP: Record<string, string> = {\n  // Part identification\n  'Number': 'componentId',\n  'Name': 'name',\n  'Count': 'quantity',\n  \n  // Dimensions (in mm from LexaCut)\n  'Cutting length': 'length',\n  'Cutting width': 'width',\n  'Cutting thickness': 'thickness',\n  \n  // Material\n  'Material name': 'materialType',\n  \n  // Instance/CNC information\n  'Entity names': 'instanceType',\n  \n  // Edge banding\n  'Edge ymin': 'edge1',\n  'Edge ymax': 'edge2',\n  'Edge xmin': 'edge3',\n  'Edge xmax': 'edge4',\n  \n  // Area\n  'Final area': 'area',\n};\n\n/**\n * Get backend field name from LexaCut column name\n * @param columnName - Column name from LexaCut CSV export\n * @returns Backend field name or null if not mapped\n */\nexport function getBackendFieldName(columnName: string): string | null {\n  // Exact match first\n  if (LEXACUT_COLUMN_MAP[columnName]) {\n    return LEXACUT_COLUMN_MAP[columnName];\n  }\n  \n  // Case-insensitive match\n  const normalizedColumn = columnName.trim();\n  for (const [key, value] of Object.entries(LEXACUT_COLUMN_MAP)) {\n    if (key.toLowerCase() === normalizedColumn.toLowerCase()) {\n      return value;\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Get all expected LexaCut column names\n * @returns Array of expected column names\n */\nexport function getExpectedColumns(): string[] {\n  return Object.keys(LEXACUT_COLUMN_MAP);\n}\n\n/**\n * Validate CSV headers against expected LexaCut columns\n * @param headers - Array of header names from CSV\n * @returns Validation result with missing and extra columns\n */\nexport function validateHeaders(headers: string[]): {\n  isValid: boolean;\n  missingColumns: string[];\n  extraColumns: string[];\n  foundColumns: string[];\n} {\n  const expectedColumns = getExpectedColumns();\n  const normalizedHeaders = headers.map(h => h.trim());\n  \n  const foundColumns: string[] = [];\n  const missingColumns: string[] = [];\n  \n  // Check for missing required columns\n  for (const expected of expectedColumns) {\n    const found = normalizedHeaders.find(\n      h => h.toLowerCase() === expected.toLowerCase()\n    );\n    if (found) {\n      foundColumns.push(expected);\n    } else {\n      // Only mark essential columns as missing\n      const essentialColumns = ['Name', 'Count', 'Cutting length', 'Cutting width', 'Material name'];\n      if (essentialColumns.includes(expected)) {\n        missingColumns.push(expected);\n      }\n    }\n  }\n  \n  // Find extra columns (informational only, not an error)\n  const extraColumns = normalizedHeaders.filter(header => {\n    return !expectedColumns.find(\n      expected => expected.toLowerCase() === header.toLowerCase()\n    );\n  });\n  \n  return {\n    isValid: missingColumns.length === 0,\n    missingColumns,\n    extraColumns,\n    foundColumns,\n  };\n}\n\n"],"names":["LEXACUT_COLUMN_MAP","getBackendFieldName","getExpectedColumns","validateHeaders","columnName","normalizedColumn","trim","key","value","Object","entries","toLowerCase","keys","headers","expectedColumns","normalizedHeaders","map","h","foundColumns","missingColumns","expected","found","find","push","essentialColumns","includes","extraColumns","filter","header","isValid","length"],"mappings":"AAAA;;;;CAIC;;;;;;;;;;;QAEYA;eAAAA;;QAgCGC;eAAAA;;QAqBAC;eAAAA;;QASAC;eAAAA;;;AA9DT,MAAMH,qBAA6C;IACxD,sBAAsB;IACtB,UAAU;IACV,QAAQ;IACR,SAAS;IAET,kCAAkC;IAClC,kBAAkB;IAClB,iBAAiB;IACjB,qBAAqB;IAErB,WAAW;IACX,iBAAiB;IAEjB,2BAA2B;IAC3B,gBAAgB;IAEhB,eAAe;IACf,aAAa;IACb,aAAa;IACb,aAAa;IACb,aAAa;IAEb,OAAO;IACP,cAAc;AAChB;AAOO,SAASC,oBAAoBG,UAAkB;IACpD,oBAAoB;IACpB,IAAIJ,kBAAkB,CAACI,WAAW,EAAE;QAClC,OAAOJ,kBAAkB,CAACI,WAAW;IACvC;IAEA,yBAAyB;IACzB,MAAMC,mBAAmBD,WAAWE,IAAI;IACxC,KAAK,MAAM,CAACC,KAAKC,MAAM,IAAIC,OAAOC,OAAO,CAACV,oBAAqB;QAC7D,IAAIO,IAAII,WAAW,OAAON,iBAAiBM,WAAW,IAAI;YACxD,OAAOH;QACT;IACF;IAEA,OAAO;AACT;AAMO,SAASN;IACd,OAAOO,OAAOG,IAAI,CAACZ;AACrB;AAOO,SAASG,gBAAgBU,OAAiB;IAM/C,MAAMC,kBAAkBZ;IACxB,MAAMa,oBAAoBF,QAAQG,GAAG,CAACC,CAAAA,IAAKA,EAAEX,IAAI;IAEjD,MAAMY,eAAyB,EAAE;IACjC,MAAMC,iBAA2B,EAAE;IAEnC,qCAAqC;IACrC,KAAK,MAAMC,YAAYN,gBAAiB;QACtC,MAAMO,QAAQN,kBAAkBO,IAAI,CAClCL,CAAAA,IAAKA,EAAEN,WAAW,OAAOS,SAAST,WAAW;QAE/C,IAAIU,OAAO;YACTH,aAAaK,IAAI,CAACH;QACpB,OAAO;YACL,yCAAyC;YACzC,MAAMI,mBAAmB;gBAAC;gBAAQ;gBAAS;gBAAkB;gBAAiB;aAAgB;YAC9F,IAAIA,iBAAiBC,QAAQ,CAACL,WAAW;gBACvCD,eAAeI,IAAI,CAACH;YACtB;QACF;IACF;IAEA,wDAAwD;IACxD,MAAMM,eAAeX,kBAAkBY,MAAM,CAACC,CAAAA;QAC5C,OAAO,CAACd,gBAAgBQ,IAAI,CAC1BF,CAAAA,WAAYA,SAAST,WAAW,OAAOiB,OAAOjB,WAAW;IAE7D;IAEA,OAAO;QACLkB,SAASV,eAAeW,MAAM,KAAK;QACnCX;QACAO;QACAR;IACF;AACF"}